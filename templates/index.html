<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>OpenCV ç»†èƒèŠ½äº¤äº’å¼è®¡æ•°</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #f0f2f5; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        h2 { color: #333; }
        .container { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); text-align: center; }
        #canvas-wrapper { position: relative; margin-top: 20px; border: 2px solid #ddd; display: inline-block; }
        canvas { cursor: crosshair; display: block; max-width: 100%; }
        .controls { margin-bottom: 15px; }
        .status { margin-top: 10px; font-weight: bold; color: #007bff; }
        button { padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background: #0056b3; }
    </style>
</head>
<body>

    <div class="container">
        <h2>ğŸ”¬ æ˜¾å¾®å›¾åƒ Bud è¯†åˆ« (OpenCV ä¼ ç»Ÿç®—æ³•ç‰ˆ)</h2>

        <div class="controls">
            <input type="file" id="uploadInput" accept="image/*">
            <span style="color: #666; font-size: 0.9em;">(ä¸Šä¼ å›¾ç‰‡ -> é¼ æ ‡æ¡†é€‰ä¸€ä¸ªèŠ½ -> è‡ªåŠ¨è®¡ç®—)</span>
        </div>

        <div id="canvas-wrapper">
            <canvas id="imgCanvas"></canvas>
        </div>

        <div class="status" id="statusText">ç­‰å¾…ä¸Šä¼ ...</div>
    </div>

    <script>
        const canvas = document.getElementById('imgCanvas');
        const ctx = canvas.getContext('2d');
        const fileInput = document.getElementById('uploadInput');
        const statusText = document.getElementById('statusText');

        let img = new Image();
        let isDrawing = false;
        let startX, startY;
        let originalImageData = null; // ä¿å­˜çº¯å‡€çš„å›¾ç‰‡æ•°æ®

        // 1. å›¾ç‰‡ä¸Šä¼ å¤„ç†
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                img.onload = () => {
                    // è®¾ç½® canvas å°ºå¯¸ä¸ºå›¾ç‰‡åŸå§‹å°ºå¯¸
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    // ä¿å­˜åŸå§‹ Base64 ç”¨äºå‘é€
                    originalImageData = event.target.result;
                    statusText.textContent = "è¯·ç”¨é¼ æ ‡åœ¨å›¾ä¸­æ¡†é€‰ä¸€ä¸ªæ ‡å‡†çš„'èŠ½'";
                }
                img.src = event.target.result;
            }
            reader.readAsDataURL(file);
        });

        // 2. é¼ æ ‡äº¤äº’ - æ¡†é€‰ ROI
        canvas.addEventListener('mousedown', (e) => {
            if(!img.src) return;
            const rect = canvas.getBoundingClientRect();
            // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ (å¦‚æœCSSç¼©æ”¾äº†Canvas)
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            startX = (e.clientX - rect.left) * scaleX;
            startY = (e.clientY - rect.top) * scaleY;
            isDrawing = true;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mouseX = (e.clientX - rect.left) * scaleX;
            const mouseY = (e.clientY - rect.top) * scaleY;

            // å®æ—¶é‡ç»˜å›¾ç‰‡å’Œé€‰æ¡†
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0);

            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.strokeRect(startX, startY, mouseX - startX, mouseY - startY);
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!isDrawing) return;
            isDrawing = false;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const endX = (e.clientX - rect.left) * scaleX;
            const endY = (e.clientY - rect.top) * scaleY;

            const w = Math.abs(endX - startX);
            const h = Math.abs(endY - startY);
            const x = Math.min(startX, endX);
            const y = Math.min(startY, endY);

            if (w < 10 || h < 10) {
                statusText.textContent = "é€‰æ¡†å¤ªå°ï¼Œè¯·é‡è¯•";
                return;
            }

            sendRoiData(x, y, w, h);
        });

        // 3. å‘é€æ•°æ®ç»™åç«¯
        function sendRoiData(x, y, w, h) {
            statusText.textContent = "æ­£åœ¨è®¡ç®—ç‰¹å¾ä¸åŒ¹é…...";

            fetch('/process', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    image: originalImageData, // å‘é€åŸå§‹å›¾ç‰‡
                    roi: { x, y, w, h }
                })
            })
            .then(response => response.json())
            .then(data => {
                if(data.error) {
                    statusText.textContent = "é”™è¯¯: " + data.error;
                    return;
                }

                // æ¸²æŸ“ç»“æœ
                const resImg = new Image();
                resImg.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(resImg, 0, 0);
                    // æ›´æ–°å½“å‰çš„æ˜¾ç¤ºå›¾ç‰‡ï¼Œä»¥ä¾¿ä¸‹æ¬¡å¯ä»¥åŸºäºç»“æœå›¾æ“ä½œï¼ˆå¦‚æœéœ€è¦ï¼‰
                    // img = resImg;
                };
                resImg.src = data.result_image;

                statusText.textContent = `è®¡ç®—å®Œæˆ! æ‰¾åˆ° ${data.count} ä¸ªç›¸ä¼¼ç›®æ ‡ (é¢ç§¯: ${Math.round(data.debug_info.template_area)})`;
            })
            .catch(err => {
                console.error(err);
                statusText.textContent = "æœåŠ¡å™¨è¿æ¥å¤±è´¥";
            });
        }
    </script>
</body>
</html>